***(
	These are the first steps towards mpOTR protocol verification and security
	analysis.
	This module focuses on the Athentication an Key Exchange phase of mpOTR.
	The protocol of the AKE phase is to big to be sited here so you can have
	a look at it online:
	http://mpotr.secsem.ru/mpOTRDev/AuthenticationKeyExchange
	We describe the Improved Deniable Signature Key-Exchange scheme here.
	
	To represent the multy-party property of mpOTR we gonna use three 
	CLients that represent people (or, more spesificly, their chat clients)
	wishing to interact with each other.
	
	Algebraic properties.
)***

--- protocol syntax - types and operations
fmod PROTOCOL-EXAMPLE-SYMBOLS is
	--- Importing sorts Msg, Fresh, Public
	protecting DEFINITION-PROTOCOL-RULES .

	--- Sort Information
	sorts Name Nonce Number Gen Exp Key GenvExp Secret Modulo Boolean Hash PubKey PrivKey SimmKey .
	----subsort Gen Exp < GenvExp .
	subsort Gen Key Modulo Hash Nonce Boolean < Number .
	subsort Name Number GenvExp Secret Key Hash < Msg .
	subsort Exp PubKey PrivKey SimmKey < Key .
	subsort Name < Public . --- means that Name info is publicly availible
	subsort Gen < Public .
	subsort Modulo < Public .
	
	--- Principals -- name constants
	ops client-1 client-2 client-3 intruder : -> Name .
	op q : -> Modulo . --- modules for nesessary calculations
	op p : -> Modulo . --- modules for nesessary calculations
  	op g : -> Gen . --- Group generator
	op 1 : -> Number . --- Base numbers
	op 0 : -> Number . 
	op true : -> Boolean .
	op false : -> Boolean .
 
	--- Secret
	op sec : Name Fresh -> Secret [frozen] .

	--- Nonce operator
	op n : Name Fresh -> Nonce [frozen] .

	--- Encryption
  	op enc : SimmKey Msg -> Msg [frozen] .
  	op dec : SimmKey Msg -> Msg [frozen] .
	
	--- Singature
	op genPriv : Name Fresh -> PrivKey [frozen] .
	op getPub : PrivKey -> PubKey [frozen] .
	op sign : PrivKey Msg -> Msg [frozen] .
	op sverify : PubKey Msg -> Msg [frozen] .
	
	--- Hash function
	op h : Msg -> Hash .

  	--- Exponent
  	op exp : Gen Number -> Exp [frozen] .
	
	--- Modulo operation
	op _mod(_) : Number Modulo -> Number .

  	--- Multiplication
  	op _*_ : Number Number -> Number [frozen assoc comm] .

	--- Sum
  	op _+_ : Number Number -> Number [frozen assoc comm] .
	
	--- Sub
  	op _-_ : Number Number -> Number [frozen] .

	--- XOR
	op _xor_ : Number Number -> Number [frozen assoc comm] .
	
	--- Concatenation
	op _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- operator prop-es-see man


endfm

--- Algebraic properties of the protocol
fmod PROTOCOL-EXAMPLE-ALGBRAIC is
	protecting PROTOCOL-EXAMPLE-SYMBOLS .
  
	--- exponent's property
  	eq exp(exp(W:Gen,Y:Number),Z:Number) 
   	= exp(W:Gen, Y:Number * Z:Number) [nonexec metadata "variant"] .
	---eq exp(W:Gen,0) = 1 [nonexec metadata "variant"] .
  
  	--- key encription property
  	eq enc(K:SimmKey,dec(K:SimmKey,M:Msg)) = M:Msg [nonexec metadata "variant"] .
  	eq dec(K:SimmKey,enc(K:SimmKey,M:Msg)) = M:Msg [nonexec metadata "variant"] .
  	
	--- signature key encription property
	eq sverify(kpub:PubKey, sign(kpriv:PrivKey, M:Msg)) 
	= M:Msg [nonexec metadata "variant"] .
		--- not really sure about this one - don't like the terminology 
	eq sign(kpriv:PrivKey, sverify(kpub:PubKey, M:Msg)) 
	= M:Msg [nonexec metadata "variant"] . 

	--- xor properties -- will this be logical xor of bit xor?
	eq X:Number * X:Number * Y:Number = Y:Number [nonexec metadata "variant"] .
	eq X:Number * X:Number = 0 [nonexec metadata "variant"] .
	eq X:Number * 0 = X:Number [nonexec metadata "variant"] .

	***(
	--- mult properties
	eq N:Number * 0 = 0 [nonexec metadata "variant"] .
	eq N:Number * 1 = N:Number [nonexec metadata "variant"] .

	--- sum properties
	eq N:Number + 0 = N:Number [nonexec metadata "variant"] .
	
	--- sub properties
	eq N:Number - 0 = N:Number [nonexec metadata "variant"] .

	--- modulo definition & property
	eq Md:Modulo mod ( Md:Modulo ) = 0 .
	eq (N:Number + Md:Modulo) mod ( Md:Modulo ) = N:Number mod ( Md:Modulo ) .
	eq (N:Number - Md:Modulo) mod ( Md:Modulo ) = N:Number mod ( Md:Modulo ) .
	eq (-- N:Number) mod (Md:Modulo) = (Md:Modulo - N:Number) mod (Md:Modulo)  .

	--- Ask someone!!
    modulo *: ab mod n = (a mod n * b mod n) mod n
	modulo exp log(exp(x) mod p) = x mod p-1

  	--- choosing q, p and g
	eq (p - 1) = 0 mod(q) . --- q is (p-1)'s divider
	eq exp(g, q) = 1 mod(p) . --- g is Zp group generator 
	)***

endfm

--- Protocol strands (what's that?)
fmod PROTOCOL-SPECIFICATION is
	protecting PROTOCOL-EXAMPLE-SYMBOLS .
	protecting DEFINITION-PROTOCOL-RULES .
	protecting DEFINITION-CONSTRAINTS-INPUT .

	vars M M1 M2 : Msg .
	var Ke : SimmKey .
	var kpub S1 S2 S3 : PubKey .
	var kpriv s1 s2 s3 : PrivKey .
	vars Num Num1 Num2 Num3 : Number .
	var N Name1 Name2 : Name .
	var GE x1 x2 x3 : Gen .
	vars y1 y2 y3 z1 z2 z3 : Number . --- or Exp? Is the reciver able to check the type?
	vars T1 T2 T3 : Number .
	vars k1_tr1 k2_tr2 k3_tr3 : Number .
	vars d1 d2 d3 : Number .
	vars k1 k2 k3 : Number . --- for symmkey Generation
	vars fr fr_k fr_x fr_r fr_s : Fresh .
	var Mod1 : Modulo .
	vars k1_h k2_h k3_h sid1 sid2 sid3 : Hash .
	vars c1_signed c2_signed c3_signed : Msg .
	
	--- Actions an intruder can perform
	eq STRANDS-DOLEVYAO =
	    --- concatenation
		:: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &
		:: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &
		:: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &
		:: nil :: [ nil | +(N), nil ] &
     	:: nil :: [ nil | -(Ke), -(M), +(enc(Ke,M)), nil ] &
     	:: nil :: [ nil | -(Ke), -(M), +(dec(Ke,M)), nil ] &
     	:: nil :: [ nil | -(M), +(h(M)), nil ] &
     	:: nil :: [ nil | -(kpriv), -(M), +(sign(kpriv,M)), nil ] &
     	:: nil :: [ nil | -(kpub), -(M), +(sverify(kpub,M)), nil ] &
     	:: nil :: [ nil | -(Num1), -(Num2), +(Num1 * Num2), nil ] &
     	:: nil :: [ nil | -(GE), -(Num), +(exp(GE,Num)), nil ] &
     	:: nil :: [ nil | -(Num1), -(Num2), +(Num1 + Num2), nil ] &
     	:: nil :: [ nil | -(Num1), -(Num2), +(Num1 - Num2), nil ] &
     	:: nil :: [ nil | -(Num1), -(Num2), +(Num1 xor Num2), nil ] &
     	:: nil :: [ nil | -(Num1), -(Mod1), +(Num1 mod( Mod1 )), nil ] &
     	:: fr ::   [ nil | +(n(intruder,fr)), nil ] &
     	:: nil :: [ nil | +(g), nil ] &
     	:: nil :: [ nil | +(p), nil ] &
     	:: nil :: [ nil | +(q), nil ] &
     	:: nil :: [ nil | +(0), nil ] &
     	:: nil :: [ nil | +(1), nil ] &
     	:: nil :: [ nil | +(true), nil ] &
     	:: nil :: [ nil | +(false), nil ] &
     	:: nil :: [ nil | +(N), nil ]
	[nonexec] .

	eq STRANDS-PROTOCOL =
		:: fr_k, fr_x, fr_s, fr_r :: 
		[nil | --- Round 1 ---
		       +(client-1 ; h(n(client-1, fr_k)) ; exp(g, n(client-1, fr_x)) ;  getPub(genPriv(client-1, fr_s))),
			   -(client-2 ; k2_h ; y2 ;  S2),
			   -(client-3 ; k3_h ; y3 ;  S3),
			   --- Round 2 --- 
		       +(client-1 ; h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; exp(g, n(client-1, fr_r))),
			   -(client-2 ; sid2 ; z2),
			   -(client-3 ; sid3 ; z3),
			   --- Round 3 ---
			   +(client-1 ; n(client-1, fr_k) xor h(exp(y2, n(client-1, fr_x))) ;  h(exp(y3, n(client-1, fr_x))) xor h(exp(y2, n(client-1, fr_x)))),
			   -(client-2 ; k2_tr2 ; T2),
			   -(client-3 ; k3_tr3 ; T3),
			   --- Round 4 ---
			   --- we have a lot of checking on this round --- where to put them?
			   --- Next phase may be
			   +(client-1 ; sign(genPriv(client-1, fr_s), (h(h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; h(exp(g, n(client-1, fr_x)) ; n(client-1, fr_k) ; getPub(genPriv(client-1, fr_s)) ; y2 ; k2 ; S2 ; y3 ; k3 ; S3)))) ; exp(g, n(client-1, fr_r)) - ((h(h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; h(exp(g, n(client-1, fr_x)) ; n(client-1, fr_k) ; getPub(genPriv(client-1, fr_s)) ; y2 ; k2_tr2 xor (T2 xor h(exp(y2, n(client-1, fr_x)))); S2 ; y3 ; k3_tr3 xor (T3 xor (T2 xor h(exp(y2, n(client-1, fr_x))))) ; S3))) * n(client-1, fr_x))), 
			   -(client-2 ; c2_signed ; d2),
			   -(client-3 ; c3_signed ; d3),
			   nil ]
			  
			  
			  ***(
			  c1 = h(sid1 ; sproof1)
			  c1 = h(h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; h(exp(g, n(client-1, fr_x)) ; n(client-1, fr_k) ; getPub(genPriv(client-1, fr_s)) ; y2 ; k2 ; S2 ; y3 ; k3 ; S3))
			  c1 = h(h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; h(exp(g, n(client-1, fr_x)) ; n(client-1, fr_k) ; getPub(genPriv(client-1, fr_s)) ; y2 ; k2_tr2 xor (T2 xor h(exp(y2, n(client-1, fr_x)))); S2 ; y3 ; k3_tr3 xor (T3 xor (T2 xor h(exp(y2, n(client-1, fr_x))))) ; S3))
			  d1 = r1 - (c1 * x1)
			  d1 = exp(g, n(client-1, fr_r))- (h(h(client-1 ; client-2 ; client-3 ; h(n(client-1, fr_k)) ; k2_h ; k3_h) ; h(exp(g, n(client-1, fr_x)) ; n(client-1, fr_k) ; getPub(genPriv(client-1, fr_s)) ; y2 ; k2_tr2 xor (T2 xor h(exp(y2, n(client-1, fr_x)))); S2 ; y3 ; k3_tr3 xor (T3 xor (T2 xor h(exp(y2, n(client-1, fr_x))))) ; S3))      * n(client-1, fr_x))
			  k2 = k2_tr2 xor (T2 xor tr1)
			  k2 = k2_tr2 xor (T2 xor h(exp(y2, n(client-1, fr_x))))
			  k3 = k3_tr3 xor (T3 xor tr2)
			  k3 = k3_tr3 xor (T3 xor (T2 xor h(exp(y2, n(client-1, fr_x)))))
			  k3 = k3_tr3 xor (T3 xor tr2)
			 )***
		***(&
		:: nil ::
		[nil | -(client-1 ; fxMess),
			   +(client-2 ; fxMess),
			   -(client-3 ; fxMess), nil]
		&
		:: nil ::
		[nil | -(client-1 ; fxMess),
			   -(client-2 ; fxMess),
			   +(client-3 ; fxMess), nil] )***
	[nonexec] .
	
	--- eq EXTRA-GRAMMARS --- increase performance = cut the search tree.
	--- [nonexec] .

	***(
	eq ATTACK-STATE(0) = 
	  	empty
		|| empty
		|| nil
		|| nil
		|| nil 
	[nonexec] .

	eq ATTACK-STATE(1) = 
		:: nil ::
		[nil,  -(Name1 ; fxMess),
			   +(client-2 ; fxMess),
			   -(Name2 ; fxMess) | nil]
		|| Name1 != client-1 
		|| nil
		|| nil
		|| nil
	[nonexec] .
	
	eq ATTACK-STATE(2) =
		:: nil ::
		[nil,  -(Name1 ; fxMess),
			   +(client-2 ; fxMess),
			   -(Name2 ; fxMess) | nil]
		|| Name2 != client-3 
		|| nil
		|| nil
		|| nil
	[nonexec] .

	eq ATTACK-STATE(3) =
		:: nil ::
		[nil,  -(Name1 ; fxMess),
			   +(client-2 ; fxMess),
			   -(Name2 ; fxMess) | nil]
		|| Name1 != client-1, 
		   Name2 != client-3
		|| nil
		|| nil
		|| nil
	[nonexec] .)***

endfm


--- THIS HAS TO BE THE LAST LOADED MODULE !!!!
select MAUDE-NPA .

***(             TRASH CAN

	eq N:Number + Md:Modulo = N:Number mod ( Md:Modulo ) .
	eq N:Number - Md:Modulo = N:Number mod ( Md:Modulo ) .
	eq Md:Modulo + N:Number = N:Number mod ( Md:Modulo ) .
	---eq N:Number = (N:Number + Md:Modulo) mod ( Md:Modulo ) .
	---eq N:Number = (N:Number - Md:Modulo) mod ( Md:Modulo ) .

)***
